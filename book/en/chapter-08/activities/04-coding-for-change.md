# Activity: Coding for Change - Problem Identification

## Overview
This activity focuses on identifying genuine problems in your community that could benefit from computational thinking solutions. By learning to recognize opportunities where programming concepts can create meaningful change, you'll connect abstract skills to concrete impact and potentially lay the groundwork for projects that improve lives. This activity emphasizes the critical first step in any programming project: clearly understanding the problem before attempting to solve it.

## Learning Objectives
- Develop skills in identifying and defining problems suitable for computational solutions
- Practice analyzing root causes rather than just symptoms
- Learn to evaluate problems based on impact, feasibility, and significance
- Apply systematic research methods to understand problems deeply
- Connect programming knowledge to community needs and priorities

## Materials Needed
- Your notebook
- Pencil or pen
- Optional: Community maps (hand-drawn is fine)
- Optional: Simple survey forms for community input
- Optional: Post-it notes or small paper slips for brainstorming

## Time Required
60-90 minutes main activity, plus optional 1-2 hours for community research

## Instructions

### Part 1: Understanding Problem-Worthy Challenges

Not all challenges are equally suited for computational thinking approaches. Let's explore what makes a problem "worthy" of a programmatic solution:

1. In your notebook, create a checklist of criteria that make a problem suitable for a programming-based solution:

- **Repetitive or Systematic**: Occurs regularly or follows patterns
- **Information-Heavy**: Involves managing, tracking, or analyzing data
- **Rule-Based**: Can be addressed through clear rules or procedures
- **Decision-Intensive**: Requires many decisions based on various factors
- **Resource-Constrained**: Involves optimizing limited resources
- **Coordination-Dependent**: Requires synchronizing multiple people or processes
- **Error-Prone**: Currently subject to human error or inconsistency
- **Scale Challenges**: Difficult to manage manually as it grows

2. Note examples of each type of problem from your own experience or observation.

### Part 2: Problem Domain Exploration

Let's explore different domains where programming concepts can create impact:

1. In your notebook, create sections for these problem domains:
   - Health and Wellbeing
   - Education and Learning
   - Environmental Sustainability
   - Economic Opportunity
   - Community Organization
   - Resource Management
   - Information Access
   - Safety and Security

2. For each domain, brainstorm at least two specific challenges or issues in your community that:
   - Affect multiple people
   - Currently lack effective solutions
   - Could potentially benefit from systematic approaches

3. For each challenge, briefly note:
   - Who is affected
   - What specific difficulties they face
   - Why existing approaches (if any) are inadequate

### Part 3: Problem Selection and Analysis

From your brainstormed list, select 2-3 problems that seem most promising for further investigation:

1. For each selected problem, conduct a deeper analysis:

   a. **Stakeholder Identification**:
      - Who is directly affected by this problem?
      - Who else has influence or interest in this issue?
      - Who might help implement or support a solution?

   b. **Root Cause Exploration**:
      - Ask "Why?" at least five times to dig beneath surface symptoms
      - Draw a simple cause-and-effect diagram showing relationships
      - Identify which causes might be addressable through systematic approaches

   c. **Impact Assessment**:
      - How many people are affected and how severely?
      - What are the broader consequences of this problem?
      - How might solving this problem create positive ripple effects?

   d. **Solution History**:
      - What approaches have been tried before?
      - Why haven't they fully succeeded?
      - What can be learned from previous attempts?

2. Create a one-page "Problem Profile" for each analyzed problem, organizing your findings clearly.

### Part 4: Community Input (Optional but Valuable)

If possible, gather input from community members about your selected problems:

1. **Informal Conversations**:
   - Discuss the problems with people affected by them
   - Ask about their experiences and perspectives
   - Note any insights that change your understanding

2. **Simple Surveys**:
   - Create a basic form with 3-5 questions about the problem
   - Gather responses from 5-10 people
   - Summarize what you learned

3. **Observation Sessions**:
   - Spend time observing the problem in context
   - Note specific instances, patterns, or variations
   - Document your observations systematically

Add what you learn to your Problem Profiles.

### Part 5: Computational Thinking Connection

Now, let's connect these problems to programming concepts:

1. For each Problem Profile, analyze how computational thinking could help:

   a. **Decomposition Application**:
      - How could breaking this problem into parts help address it?
      - What natural subdivisions exist within this challenge?

   b. **Pattern Identification**:
      - What patterns or trends might be important to recognize?
      - How could recognizing patterns help solve this problem?

   c. **Abstraction Opportunities**:
      - What details could be simplified or generalized?
      - How might abstracting the problem make it more manageable?

   d. **Algorithmic Approaches**:
      - What step-by-step procedures might address this problem?
      - What decision rules would be helpful?

   e. **Data Considerations**:
      - What information would need to be collected?
      - How would data be organized and processed?

2. Create a "Computational Connection" section for each Problem Profile, documenting these insights.

### Part 6: Feasibility Assessment

Evaluate how feasible a computational solution would be with available resources:

1. For each problem, assess:

   a. **Resource Requirements**:
      - What would be needed to implement a solution?
      - What skills, materials, or support would be required?

   b. **Constraints and Limitations**:
      - What obstacles might make implementation difficult?
      - How might these be addressed or worked around?

   c. **Scalability and Sustainability**:
      - Could the solution grow if successful?
      - How might it be maintained over time?

   d. **Potential Risks**:
      - What could go wrong or have unintended consequences?
      - How might risks be mitigated?

2. Create a simple scoring system (1-5 scale) and rate each problem on:
   - Impact potential
   - Technical feasibility
   - Resource requirements
   - Community support
   - Your personal interest/motivation

### Part 7: Problem Statement Formulation

For your highest-scoring problem, craft a clear, comprehensive problem statement:

1. Write a problem statement that includes:
   - Who is affected
   - What specific challenge they face
   - Why it matters
   - What an ideal solution would accomplish
   - What constraints must be considered
   - How success would be measured

2. Refine your statement until it:
   - Is specific rather than general
   - Focuses on the problem, not a particular solution
   - Is concise but complete
   - Captures the essence of what needs to be addressed

Your final problem statement should fit on a single page and clearly communicate the challenge to someone unfamiliar with the situation.

## Example Problem Profile

Here's an example of a completed Problem Profile:

```
PROBLEM PROFILE: Inconsistent Medication Adherence Among Elderly Residents

Stakeholders:
- Elderly residents (primary)
- Family caregivers
- Community health workers
- Local clinic staff

Root Causes:
- Complex medication schedules difficult to remember
- Limited literacy makes instructions challenging
- Visual impairments affect ability to identify pills
- No systematic reminder system
- Inconsistent family support
- Limited health worker visits

Impact:
- Affects approximately 60 elderly residents in the community
- Results in preventable health complications
- Increases emergency clinic visits by ~30%
- Creates stress for family members
- Reduces effectiveness of treatment plans

Previous Approaches:
- Verbal instructions from health workers (forgotten)
- Written schedules (not accessible to all)
- Family reminders (inconsistent)
- Pill boxes (confusing for multiple medications)

COMPUTATIONAL CONNECTION:

Decomposition:
- Break down by time of day (morning/noon/evening/night)
- Separate by medication type
- Divide responsibility between self-management and support

Pattern Recognition:
- Identify common error patterns
- Recognize daily routines to link medications to
- Track adherence patterns to identify improvement opportunities

Abstraction:
- Simplify complex medical instructions
- Create universal visual symbols for different medications
- Standardize schedule representation

Algorithmic Approaches:
- Decision tree for medication identification
- Step-by-step verification process
- Clear procedure for missed dose situations

Data Considerations:
- Medication inventory tracking
- Adherence history
- Health outcome correlation

FEASIBILITY ASSESSMENT:

Resource Requirements:
- Simple tracking forms
- Visual identification system
- Community health worker training
- Family education materials
- Score: 4/5 (relatively low resource needs)

Constraints:
- Limited literacy
- Visual impairments
- Varying family support
- Infrequent professional contact
- Score: 3/5 (significant but manageable)

Scalability:
- Could expand to nearby communities
- Adaptable to different health conditions
- Potential for simple technology integration later
- Score: 4/5 (good scaling potential)

Risk Assessment:
- Medical errors possible if system fails
- Dependency on system could develop
- Privacy concerns with health information
- Score: 3/5 (manageable with proper design)

PROBLEM STATEMENT:

Elderly residents in our community struggle to consistently take their medications as prescribed due to complex regimens, memory challenges, limited literacy, and visual impairments. This leads to preventable health complications, increased emergency care, and stress for families. Current approaches rely on verbal instructions or written schedules that aren't accessible to all, while family support varies significantly. A successful solution would create a systematic, accessible system for medication management that accommodates varying literacy levels and visual abilities, provides clear verification steps, and coordinates available support resources. Success would be measured by improved medication adherence rates, reduced health complications, and increased confidence among elderly residents in managing their health. Any solution must be implementable with minimal resources, maintainable by community members, and respectful of privacy concerns.
```

## Variations

### Youth Focus
Adapt this activity specifically for identifying problems affecting young people in your community, having youth themselves lead the problem identification process.

### Resource Mapping Approach
Combine problem identification with community resource mapping to identify both challenges and existing assets that could contribute to solutions.

### Technology Transition Planning
Focus specifically on problems that are currently handled manually but could benefit from technological solutions when resources become available.

### Single-Domain Deep Dive
Instead of exploring multiple domains, conduct a deeper exploration of a single domain of particular importance to your community (health, education, etc.).

## Extension Activities

### 1. Stakeholder Interviews
Conduct structured interviews with 3-5 key stakeholders for your priority problem, documenting their perspectives and insights to deepen your understanding.

### 2. Problem Visualization
Create a visual representation of your priority problem using diagrams, maps, or illustrated scenarios that help others understand the issue's complexity and impact.

### 3. Comparative Problem Analysis
Research how similar problems have been addressed in other communities or contexts, documenting approaches that might be adapted to your situation.

### 4. Solution Prerequisites Workshop
Organize a small group discussion to identify the specific prerequisites (skills, resources, support) needed before attempting to solve your priority problem.

## Reflection Questions

1. How has your understanding of what makes a "good problem" for computational thinking changed through this activity?
2. What surprised you about the process of deeply analyzing a problem before considering solutions?
3. How might your background and experiences give you unique insights into certain types of problems?
4. What challenges did you face in trying to clearly define problems in your community?
5. How does systematic problem identification differ from the way problems are typically discussed in your community?

## Connection to Programming

Professional programmers understand that clearly defining the problem is often the most critical step in developing effective solutions. As the famous computer scientist Donald Knuth once said, "Premature optimization is the root of all evil." In other words, trying to solve a problem before fully understanding it often leads to ineffective or misguided solutions.

The skills you've practiced in this activity mirror the "requirements gathering" and "problem definition" phases of professional software development. Before writing a single line of code, effective programmers invest significant time in:

1. **Understanding user needs** through research and stakeholder engagement
2. **Defining problem boundaries** to clarify what is in and out of scope
3. **Analyzing root causes** rather than just addressing symptoms
4. **Evaluating constraints** that will shape potential solutions
5. **Documenting clear problem statements** that guide development efforts

These practices help ensure that the eventual solution—whether implemented through traditional programming or other computational approaches—addresses the real problem effectively and efficiently.

By developing your problem identification skills, you're building an essential foundation for effective programming, even before you write any code. These skills transfer directly to digital contexts when technology becomes available, and they're immediately applicable for developing non-digital systems that implement computational thinking principles.
